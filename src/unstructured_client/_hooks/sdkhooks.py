"""Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT."""

import httpx
import inspect
from .types import (
    SDKInitHook,
    BeforeRequestContext,
    BeforeRequestHook,
    AfterSuccessContext,
    AfterSuccessHook,
    AfterErrorContext,
    AfterErrorHook,
    AsyncSDKInitHook,
    AsyncBeforeRequestHook,
    AsyncAfterSuccessHook,
    AsyncAfterErrorHook,
    Hooks,
)
from .registration import init_hooks
from typing import List, Optional, Tuple, Union
from unstructured_client.httpclient import AsyncHttpClient, HttpClient


class SDKHooks(Hooks):
    def __init__(self) -> None:
        self.sdk_init_hooks: List[SDKInitHook] = []
        self.before_request_hooks: List[BeforeRequestHook] = []
        self.after_success_hooks: List[AfterSuccessHook] = []
        self.after_error_hooks: List[AfterErrorHook] = []
        self.async_sdk_init_hooks: List[AsyncSDKInitHook] = []
        self.async_before_request_hooks: List[AsyncBeforeRequestHook] = []
        self.async_after_success_hooks: List[AsyncAfterSuccessHook] = []
        self.async_after_error_hooks: List[AsyncAfterErrorHook] = []
        init_hooks(self)

    def register_sdk_init_hook(self, hook: SDKInitHook) -> None:
        self.sdk_init_hooks.append(hook)

    def register_before_request_hook(self, hook: BeforeRequestHook) -> None:
        self.before_request_hooks.append(hook)

    def register_after_success_hook(self, hook: AfterSuccessHook) -> None:
        self.after_success_hooks.append(hook)

    def register_after_error_hook(self, hook: AfterErrorHook) -> None:
        self.after_error_hooks.append(hook)

    def register_async_sdk_init_hook(self, hook: AsyncSDKInitHook) -> None:
        self.async_sdk_init_hooks.append(hook)

    def register_async_before_request_hook(self, hook: AsyncBeforeRequestHook) -> None:
        self.async_before_request_hooks.append(hook)

    def register_async_after_success_hook(self, hook: AsyncAfterSuccessHook) -> None:
        self.async_after_success_hooks.append(hook)

    def register_async_after_error_hook(self, hook: AsyncAfterErrorHook) -> None:
        self.async_after_error_hooks.append(hook)

    def sdk_init(self, base_url: str, client: HttpClient) -> Tuple[str, HttpClient]:
        for hook in self.sdk_init_hooks:
            base_url, client = hook.sdk_init(base_url, client)
        return base_url, client

    def before_request(
        self, hook_ctx: BeforeRequestContext, request: httpx.Request
    ) -> httpx.Request:
        for hook in self.before_request_hooks:
            out = hook.before_request(hook_ctx, request)
            if isinstance(out, Exception):
                raise out
            request = out

        return request

    def after_success(
        self, hook_ctx: AfterSuccessContext, response: httpx.Response
    ) -> httpx.Response:
        for hook in self.after_success_hooks:
            out = hook.after_success(hook_ctx, response)
            if isinstance(out, Exception):
                raise out
            response = out
        return response

    def after_error(
        self,
        hook_ctx: AfterErrorContext,
        response: Optional[httpx.Response],
        error: Optional[Exception],
    ) -> Tuple[Optional[httpx.Response], Optional[Exception]]:
        for hook in self.after_error_hooks:
            result = hook.after_error(hook_ctx, response, error)
            if isinstance(result, Exception):
                raise result
            response, error = result
        return response, error

    async def sdk_init_async(
        self, base_url: str, client: AsyncHttpClient
    ) -> Tuple[str, AsyncHttpClient]:
        # Run async hooks first
        for hook in self.async_sdk_init_hooks:
            base_url, client = await hook.sdk_init_async(base_url, client)
        # Then run sync hooks for backward compatibility (if hook has sync version)
        for hook in self.sdk_init_hooks:
            # Cast the client temporarily - sync hooks may not touch async client
            base_url, _ = hook.sdk_init(base_url, client)  # type: ignore
        return base_url, client

    async def before_request_async(
        self, hook_ctx: BeforeRequestContext, request: httpx.Request
    ) -> httpx.Request:
        # Run async hooks first
        for hook in self.async_before_request_hooks:
            out = await hook.before_request_async(hook_ctx, request)
            if isinstance(out, Exception):
                raise out
            request = out

        # Then run sync hooks for backward compatibility
        for hook in self.before_request_hooks:
            out = hook.before_request(hook_ctx, request)
            if isinstance(out, Exception):
                raise out
            request = out

        return request

    async def after_success_async(
        self, hook_ctx: AfterSuccessContext, response: httpx.Response
    ) -> httpx.Response:
        # Run async hooks first
        for hook in self.async_after_success_hooks:
            out = await hook.after_success_async(hook_ctx, response)
            if isinstance(out, Exception):
                raise out
            response = out

        # Then run sync hooks for backward compatibility
        for hook in self.after_success_hooks:
            out = hook.after_success(hook_ctx, response)
            if isinstance(out, Exception):
                raise out
            response = out

        return response

    async def after_error_async(
        self,
        hook_ctx: AfterErrorContext,
        response: Optional[httpx.Response],
        error: Optional[Exception],
    ) -> Tuple[Optional[httpx.Response], Optional[Exception]]:
        # Run async hooks first
        for hook in self.async_after_error_hooks:
            result = await hook.after_error_async(hook_ctx, response, error)
            if isinstance(result, Exception):
                raise result
            response, error = result

        # Then run sync hooks for backward compatibility
        for hook in self.after_error_hooks:
            result = hook.after_error(hook_ctx, response, error)
            if isinstance(result, Exception):
                raise result
            response, error = result

        return response, error
